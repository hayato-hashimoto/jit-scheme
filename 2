(use srfi-1)
(use gauche.sequence)

(define registers32 '(eax ecx edx ebx esp ebp esi edi))
(define registers64 '(rax rcx rdx rbx rsp rbp rsi rdi))
(define registers64-extra '(r8 r9 r10 r11 r12 r13 r14 r15))

(define (enc bits len value)
  (let1 v (mod value (expt 256 len))
    (if (eq? len 0)
      '() 
      (cons (logand (lognot (ash -1 bits)) v) (enc bits (- len 1) (ash v (- bits)))))))

(define (regi regsym)
    (or (list-index (pa$ eq? regsym) registers32)
        (list-index (pa$ eq? regsym) registers64)))

(define (opadd64 r1 r2)
  `(#x48 #x01 ,(logior #xc0 (regi r1) (ash (regi r2) 3))))

(define (opstore64 r1 r2)
  `(#x48 #x89 ,(logior (regi r1) (ash (regi r2) 3))))

(define (opread64 r1 r2)
  `(#x48 #x8b ,(logior (regi r2) (ash (regi r1) 3))))

(define (opconst64 r1 i1)
  `(#x48 ,(logior #xB8 (regi r1)) ,@(enc 8 8 i1)))

(define (opimul64 r1 r2)
  `(#x48 #x0F #xAF ,(logior #xC0 (regi r2) (ash (regi r1) 3))))
  
(define (ret)
  '(#xc3))

(define (malloc r1)
  (opconst64 'ebx 8556)
  (opread64  'edx 'ebx)
  (opconst64 'ebx 8564)
  (opstore64 'ebx 'edx))

; lambda-term expr[a1/b1][a2/b2] ...
(define (opcode-r expr a)
  (cond
    ((and (pair? expr)) (car expr) 'lambda
       (opcode-r (caddr expr) (cons (cons arg read) a))
; assert (car expr) is-a instruction and not be rebound
    ((and (pair? expr) (eq? (car expr) opread64))
      (append
        (opcode-r (cadr expr) a)
        ((car expr) 'eax 'eax)))
; assert (car expr) is-a 2-argument 2-in instruction
    ((pair? expr)
      (append 
        (opcode-r (cadr expr) a)
        (opstore64 'rdi 'eax)
        (opconst64 'ebx -8)
        (opadd64   'rdi 'ebx)
        (opcode-r (caddr expr) a)
        (opconst64 'ebx 8)
        (opadd64 'rdi 'ebx)
        (opread64 'ebx 'rdi)
        ((car expr) 'eax 'ebx)))
    ((assq expr a) (cdr (assq expr a)))
    (else
; assert expr be numeric
        (opconst64 'eax expr))))

(define (opcode expr)
  (cond
; assert (car expr) is-a instruction and not be rebound
    ((and (pair? expr) (eq? (car expr) opread64))
      (append
        (opcode (cadr expr))
        ((car expr) 'eax 'eax)))
; assert (car expr) is-a 2-argument 2-in instruction
    ((pair? expr)
      (append 
        (opcode (cadr expr))
        (opstore64 'rdi 'eax)
        (opconst64 'ebx -8)
        (opadd64   'rdi 'ebx)
        (opcode (caddr expr))
        (opconst64 'ebx 8)
        (opadd64 'rdi 'ebx)
        (opread64 'ebx 'rdi)
        ((car expr) 'eax 'ebx)))
; assert expr be numeric
    (else (opconst64 'eax expr))))

(define (main args)
  (display "binary-test> ") (flush)
  (let1 s (read)
    (with-output-to-file "output.bin" (^()
        (for-each write-byte (append (opconst64 'rdi 8448) (opconst64 'rbp 8448) (opcode (compile s)) (opstore64 'rdi 'eax) (ret))))))
  (sys-system "ndisasm output.bin -b64")
  (sys-system "./a.out output.bin")
  (test))

(define (compile s a level)
  (cond
    ((not (pair? s)) s)
    ((eq? (car s) '+)      (cons opadd64  (map compile (cdr s))))
    ((eq? (car s) '*)      (cons opimul64 (map compile (cdr s))))
    ((eq? (car s) 'read)   (cons opread64 (map compile (cdr s))))
    ((eq? (car s) 'set!)   (list opstore64 (compile (caddr s)) (compile (cadr s))))
    ((eq? (car s) 'lambda) (cons '%lambda  (compile (caddr s) (cons (cons (cadr s) 
(opmov rsi rbp)
(opadd64 rsi ,level)
(opread64 rbp level)) a) (+ 8 level))))
    (else (cons (car s) (compile (cdr s))))))
